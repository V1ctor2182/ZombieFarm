
**META-SUNFLOWERLAND-REFERENCE.md**  
```markdown
---
title: "Zombie Farm - Sunflower Land Reference"
last updated: 2025-11-12
author: Solo Dev
---

# Sunflower Land Reference

Zombie Farm’s development leverages the open-source **Sunflower Land** game (a farming game built with React/TypeScript) as a reference for proven patterns, components, and systems. This section catalogs the key elements from Sunflower Land that we plan to reuse or adapt in Zombie Farm, along with context on how they inform our implementation.

Sunflower Land provides a rich codebase of farming mechanics and UI elements that closely align with what we need, reducing reinventing the wheel. Below are major areas of reuse:

## UI Components and Layout
- **Reusable Components**: Sunflower Land has a library of generic UI components (in `src/components/`). For example:
  - `ErrorMessage.tsx` – A simple component to display error alerts to the user. We will reuse this for showing game errors (e.g. “Not enough resources” messages).
  - Modal components like `PlayerModal.tsx` and `RewardModal.tsx` – These provide a base for popup dialogs. We will create our own modals (e.g., a **Zombie Detail Modal** or **Settings Modal**) following the same pattern (backdrop, content centered, close button) as these references.
  - HUD elements – The farming HUD in Sunflower Land (found under `features/farming/hud/`) shows inventory, balance, etc. We will adapt this to our **Farm HUD** (to display Dark Coins, resources like wood/bones, etc.) maintaining a similar layout and responsive behavior.
- **Design System & Styles**: The reference uses Tailwind CSS with custom configuration for pixel art styling. We have adopted the same Tailwind setup:
  - The `tailwind.config.js` from Sunflower Land includes settings to preserve crisp pixels (e.g., using `image-rendering: pixelated`) and custom color palette for the farm theme. We will use these configurations as a baseline, adjusting colors to fit Zombie Farm’s darker, spooky aesthetic where needed.
  - A theme CSS (e.g. `styles/zombie-theme.css`) from the reference project provides base styles (fonts, background colors, UI panel styles) which we adapt for consistency. This ensures our UI elements (buttons, menus) have a familiar look and feel.
- **Responsive & Mobile UI**: Sunflower Land’s UI components are designed to scale to different screen sizes (mobile vs desktop). We will reuse responsive patterns (CSS flex layouts, grid arrangements) seen in their components. For instance, the inventory and shop UIs in Sunflower Land reflow for smaller screens – we aim to achieve similar responsiveness for Zombie Farm’s UI by examining how Sunflower Land’s components use Tailwind utility classes for responsive breakpoints.
- **Icons and Images**: The `public/` assets in Sunflower Land include many icons (resources, items) and images that can serve as placeholders or even final assets for Zombie Farm. For example, Sunflower Land’s resource icons (wood, stone, etc.) can be repurposed by re-theming them (the **Rotten Wood** icon might reuse the wood icon with a tint, etc.). We’ll follow their approach of storing such assets in logical subdirectories (`public/farms/*.png` for farm-related icons, etc.) and loading them via import or image paths as needed.
- **Menu Navigation**: The reference game likely includes navigation components like a settings menu, trading post, etc. While Zombie Farm’s gameplay is different, any standard menus (e.g., a main menu or settings panel) will borrow from the structure of Sunflower Land’s equivalents (e.g., similar to how `Navigation.tsx` in Sunflower Land organizes different game screens).

## Game Systems and Logic
- **Event System**: Sunflower Land implements an extensive event-driven logic for game actions. Under `src/features/game/events/` there are numerous event handlers (e.g., planting crops, harvesting, feeding animals). We will mirror this design:
  - We define events such as `plantZombie`, `harvestZombie`, `feedZombie`, `battleStart`, etc., analogous to Sunflower Land’s events. Each event is a function that takes the current game state and an action payload, and returns an updated state. By reviewing Sunflower Land’s event implementations (like how planting reduces seeds and adds a crop), we ensure our events handle all necessary checks (inventory, timing, etc.).
  - The idea of segregating events by category (Sunflower Land has sub-folders like `landExpansion`, `minigames`, etc.) will be used to organize Zombie Farm’s events. For example, farm-related events vs combat-related events can live in separate modules, keeping the codebase organized.
- **Finite State Machine**: The reference uses a global game state machine (`gameMachine`) in the **game** feature to manage game logic and progression:contentReference[oaicite:24]{index=24}. We will reuse this concept directly:
  - Our `gameMachine` will incorporate states and transitions similar to Sunflower Land’s, but tailored to Zombie Farm (states like Farming, Combat, perhaps Tutorial, GameOver, etc.). The XState configuration from Sunflower Land serves as a template for handling complex sequences (e.g., a guided tutorial sequence or a multi-step battle).
  - We will include similar state branches for things like offline progress or session management if needed. Additionally, Sunflower Land’s use of XState context to hold game data (farm state, player data) guides how we structure our context data.
- **Saving & Loading**: Sunflower Land’s local storage system (`lib/storage/localSaveSystem.ts`):contentReference[oaicite:25]{index=25} provides methods to save the game state to the browser and load it back. We plan to either directly utilize this module or write our own based on it. It likely uses `localStorage` under the hood to persist game JSON. By following their implementation, we avoid pitfalls (like exceeding storage quotas or needing to version save data). We’ll adapt keys and content to our game (e.g., storing zombie-specific data), but the read/write flow remains the same.
- **Configuration & Balancing**: The reference project contains config files for game balance, e.g., `src/features/game/lib/balance.ts` or `zombieFarmConfig.ts`. These files define constants such as crop growth times, experience points, etc. We have a similar **config module** in Zombie Farm:
  - `lib/config/zombieFarmConfig.ts` collects all our tunable parameters (zombie growth durations, decay rates, combat damage factors, etc.). We started from Sunflower Land’s config values as a baseline (for example, using similar growth time for a basic crop as for a basic zombie, adjusted for gameplay).
  - If Sunflower Land had quality tiers or rarity definitions for crops, we adapt those for zombie quality (e.g., Common, Uncommon, Rare zombies concept). The reference’s balancing of resource generation and sinks gives us insight into setting up a balanced economy in Zombie Farm.
- **Inventory and Crafting**: Sunflower Land features an inventory system for resources and crafted items. We plan to reuse data structures and possibly UI elements for our inventory:
  - The inventory might be represented as a simple map of item -> quantity in Sunflower Land. We’ll use the same approach for resources (e.g., `"Rotten Wood": 20, "Bones": 15` in an inventory object). This makes implementing item pickups and usage straightforward and consistent.
  - Crafting or building in Zombie Farm (like constructing a new plot or mixing a potion) can follow the recipe pattern from Sunflower Land. In the reference, building a bumpkin or crafting requires certain ingredients; analogously, we’ll define recipes in config and use a generic crafting function to check inventory and deduct ingredients.
- **Economy & Currencies**: Sunflower Land’s economy (with its coins and tokens) is being mirrored. In the reference:
  - **SFL (Sunflower Land coin)** is the primary in-game currency, which we replace with **Dark Coins** in Zombie Farm. Sunflower Land’s logic for earning/spending SFL (rewards from quests, costs for items) guides our implementation of Dark Coin transactions. For example, Sunflower Land might have a function like `addBalance` or events for spending coins; we will implement similar events for Dark Coins (gaining from battles, spending on seeds or expansions).
  - Secondary currencies or premium items: Sunflower Land has items like Gold, or in events maybe premium tokens. Our design introduces **Soul Essence** as a rare currency. We’ll follow how Sunflower Land handles premium tokens (ensuring they’re tracked separately and not easily farmable) and possibly reuse UI indicators for these.
  - Resource generation and decay: The reference includes mechanics like crops spoiling or resources decaying over time. We plan to reuse these ideas (e.g., limiting hoarding by having certain resources rot). If Sunflower Land has a system for item decay, we can adapt that for things like *Rotten Meat* spoiling if not used, similar to how their food might spoil.

## Visual & Animation Systems
- **Sprite Sheets & Animation**: The Sunflower Land repository includes an `assets` directory with sprite sheets and the code to animate them:
  - `components/animation/SpriteAnimator.tsx` – This component (and associated logic) can display a series of sprite images as an animation (for example, a character walking or a crop growing). We will reuse this system to animate zombies (for idle animations, walking cycles) and potentially certain UI effects (like animated icons).
  - The reference likely uses **Aseprite** or sprite sheets (they even include an `aseprite` directory with an `art_competition.aseprite.zip`). We will follow their pipeline: create sprite sheets for zombie animations and use the SpriteAnimator to cycle through frames. For instance, if we have a 4-frame zombie walking animation, we load it similarly to how Sunflower Land loads its animated assets and let their animator handle the frame timing.
  - **ResourceDropAnimator**: In Sunflower Land, when resources are collected, an animation might play (e.g., coins popping out). We will adapt `ResourceDropAnimator.tsx` to animate resource pickups in Zombie Farm – for example, when a battle yields Dark Coins, animate coins flying towards the coin counter.
- **Character and World Rendering**: The reference’s `world/` feature provides a blueprint for rendering the game world using Phaser:
  - `world/Phaser.tsx` and `world/World.tsx` – These files handle initializing the Phaser game instance and bridging it with React. We will use them as a starting point to create our **World component**. The `World.tsx` likely sets up Phaser scenes for different areas (farm, town, etc.). We’ll configure our version to load the Farm scene with tilemaps and sprites for zombies/humans.
  - **Navmesh & Pathfinding**: Sunflower Land uses `phaser-navmesh` for NPC pathfinding in the world. We intend to reuse this for zombie movement on the farm. By studying how the reference integrates the navmesh plugin, we can implement zombie wanderings and chasing in our top-down farm scene without writing pathfinding from scratch.
  - **Shaders and Effects**: The `world/shaders/` folder in Sunflower Land suggests they use custom shaders for visual effects. If relevant (for example, a night-time shader or a spooky glow effect), we can take inspiration from those shaders to enhance the visual atmosphere of Zombie Farm.
- **Pixel Art Assets**: Sunflower Land’s art assets (e.g., crops, animals, decorations) set a style precedent. We will match that style for Zombie Farm’s art:
  - **Size and Scale**: Many Sunflower Land assets appear to be 32x32 pixels or similar small sizes (their `public/brand/32x32.png` suggests an icon size). We will create zombie sprites and tiles in comparable resolutions so that they blend with any reused assets and fit the engine with minimal scaling issues.
  - **Environment Tiles**: If the reference has tiles for ground, water, etc., we might reuse those for our farm’s base terrain initially (recoloring as needed). This jumpstarts level design for the farm and world map.
  - **Animations for Growing**: In Sunflower Land, each plant has a growing and ready image (e.g., `blue_carnation_growing.webp` vs `blue_carnation_ready.webp`). We emulate this by creating distinct sprites for each zombie growth stage (perhaps a “buried coffin” sprite for planted, a “rising hand” sprite for almost ready, etc.). The concept of having separate assets for growth stages is directly borrowed from the flower growth assets in Sunflower Land.
  - **UI Feedback**: Visual cues like particles or emoticons above characters (Sunflower Land might show an icon when a crop is ready or an animal is hungry) are reused. For example, we might show a meat icon over a zombie when it’s hungry – this can be done by adapting similar mechanics from their animals (if, say, chickens had an icon when unfed).

## Adaptation Strategy
While we have many assets to reuse, we will adapt them to fit Zombie Farm’s unique theme:
- All blockchain and NFT-related code is omitted (as per Sunflower Land’s code exclusions). We focus only on core gameplay components.
- Multiplayer server references (e.g., Colyseus) are not used initially, but the code structure for connecting to a server is in place if we expand later. For now, any multiplayer-specific sections in `world/` or elsewhere will be stubbed or removed.
- Some systems in Sunflower Land have no counterpart in Zombie Farm (for example, pet system, trading marketplace). We won’t include those, but their presence in the reference reminds us to keep our architecture flexible for future features.
- Naming conventions from the reference are followed for consistency. E.g., we use similar file and folder naming (lowercase, and categorize by feature), and similar coding styles (their code is a helpful guide for our code style).

By utilizing the Sunflower Land reference, we accelerate development—proven code for rendering, saving, UI, and more can be directly applied or lightly modified. This reduces bugs and aligns Zombie Farm with a familiar structure that new contributors (who may know Sunflower Land) can understand quickly. As we implement, we will frequently consult the reference code to answer questions like “How did Sunflower handle X?”, ensuring we build on lessons learned from that project.
